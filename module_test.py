# -*- coding: utf-8 -*-
"""module_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FdlBrgUSoonWZR5JIhJ4dtRhUj2WUssT
"""

class UnderlayNode:
    def __init__(self, node_id):
        self.node_id = node_id
        self.links = []

    def add_link(self, link):
        self.links.append(link)

class UnderlayLink:
    def __init__(self, source, destination, capacity, delay, traffic_utility):
        self.source = source
        self.destination = destination
        self.capacity = capacity
        self.delay = delay
        self.traffic_utility = traffic_utility

class OverlayNode:
    def __init__(self, virtual_id):
        self.virtual_id = virtual_id
        self.virtual_links = []

    def add_virtual_link(self, vlink):
        self.virtual_links.append(vlink)

class OverlayLink:
    def __init__(self, source, destination, mapped_links):
        self.source = source
        self.destination = destination
        self.mapped_links = mapped_links  # List of UnderlayLinks

class UnderlayNetwork:
    def __init__(self):
        self.nodes = {}
        self.links = []

    def add_node(self, node):
        self.nodes[node.node_id] = node

    def add_link(self, link):
        self.links.append(link)
        link.source.add_link(link)
        link.destination.add_link(link)

    def calculate_routing_table(self):
        routing_table = {}
        for node_id, node in self.nodes.items():
            for target_id, target in self.nodes.items():
                if node_id != target_id:
                    path = self.find_path(node, target)
                    if path:
                        routing_table[(node_id, target_id)] = path
        return routing_table

    def find_path(self, source, destination):
        for link in source.links:
            if link.destination == destination:
                return [link]
        return []  # No direct path

# Example Usage
# Initialize Underlay Network
underlay_network = UnderlayNetwork()

# Create Nodes and Links
node_a = UnderlayNode("A")
node_b = UnderlayNode("B")
node_c = UnderlayNode("C")

underlay_network.add_node(node_a)
underlay_network.add_node(node_b)
underlay_network.add_node(node_c)

link_ab = UnderlayLink(node_a, node_b, 1, 20, 0.2)
link_bc = UnderlayLink(node_b, node_c, 1, 30, 0.2)
link_ca = UnderlayLink(node_c, node_a, 1, 40, 0.2)

underlay_network.add_link(link_ab)
underlay_network.add_link(link_bc)
underlay_network.add_link(link_ca)

# Calculate Routing Table
routing_table = underlay_network.calculate_routing_table()

# Displaying the Routing Table
for key, path in routing_table.items():
    print(f"Path from {key[0]} to {key[1]}: {[f'{link.source.node_id}->{link.destination.node_id}' for link in path]}")

# Creating Underlay Network
node_a = UnderlayNode("A", 1000)
node_b = UnderlayNode("B", 1000)
link_ab = UnderlayLink(node_a, node_b, 500, 10)
node_a.add_link(link_ab)
node_b.add_link(link_ab)

# Creating Overlay Network
virtual_node_1 = OverlayNode("V1")
virtual_node_2 = OverlayNode("V2")
overlay_link = OverlayLink(virtual_node_1, virtual_node_2, [link_ab])
virtual_node_1.add_virtual_link(overlay_link)
virtual_node_2.add_virtual_link(overlay_link)

import random
from collections import defaultdict, deque
import heapq

# Initialize the graph
G = {'V': set(), 'E': defaultdict(dict)}

# Function to add a node to the graph
def add_node(node):
    G['V'].add(node)

# Function to add an edge to the graph
def add_edge(u, v):
    weight = random.randint(10, 100)  # Use propagation delay as the weight for the MST
    G['E'][(u, v)] = {
        'capacity': '1Gbps',
        'propagation_delay': weight,  # in microseconds
        'background_traffic': random.uniform(15, 35)  # in percentage
    }
    # Since this is an undirected graph, add the edge in both directions
    G['E'][(v, u)] = G['E'][(u, v)]
    add_node(u)
    add_node(v)

# Prim's algorithm to find MST
def prims_algorithm(start_node):
    mst = defaultdict(set)
    visited = set([start_node])
    edges = [(weight, start_node, to) for to, weight in G['E'][start_node].items()]

    heapq.heapify(edges)

    while edges:
        weight, frm, to = heapq.heappop(edges)
        if to not in visited:
            visited.add(to)
            mst[frm].add(to)
            for to_next, properties in G['E'][to].items():
                if to_next not in visited:
                    heapq.heappush(edges, (properties['propagation_delay'], to, to_next))

    return mst

# Generate the routing table based on the MST
def generate_routing_table(mst):
    routing_table = defaultdict(list)

    # Helper function to build paths in the routing table
    def build_paths(start, destination, path, visited):
        visited.add(start)
        path.append(start)
        if start == destination:
            return path
        for next_node in mst[start]:
            if next_node not in visited:
                result = build_paths(next_node, destination, list(path), visited)
                if result is not None:
                    return result
        visited.remove(start)
        path.pop()
        return None

    # Build routing paths for each pair of nodes
    for u in G['V']:
        for v in G['V']:
            if u != v:
                path = build_paths(u, v, [], set())
                if path:
                    routing_table[(u, v)] = [(path[i], path[i + 1]) for i in range(len(path) - 1)]

    return routing_table

# Example of adding nodes and edges
add_edge('A', 'B')
add_edge('B', 'C')
add_edge('C', 'D')
add_edge('D', 'A')
add_edge('A', 'C')  # Adding an additional edge to ensure connectivity

# Calculate the minimum spanning tree
mst = prims_algorithm('A')

# Generate the routing table based on the MST
routing_table = generate_routing_table(mst)

# Print the graph, the MST, and routing table
print("Graph Nodes:", G['V'])
print("Graph Edges:", G['E'])
print("Minimum Spanning Tree:", dict(mst))
print("Routing Table:", dict(routing_table))

import networkx as nx

def create_underlay_network(num_nodes):
    # Create an empty graph
    underlay = nx.Graph()

    # # Add nodes
    # for i in range(num_nodes):
    #     underlay.add_node(i)

    # # Add edges with capacity and delay as attributes
    # # In a real scenario, these would be based on actual network data
    # underlay.add_edge(0, 1, capacity=10, delay=5)
    # underlay.add_edge(1, 2, capacity=15, delay=10)
    # # ... more edges based on your network design

    # Add more nodes
    for i in range(num_nodes):  # Increasing the number of nodes to 10
        underlay.add_node(i)

    # Add more edges with capacity and delay as attributes
    edges = [
        (0, 1, 10, 5), (1, 2, 15, 10), (2, 3, 10, 5), (3, 4, 20, 15),
        (4, 5, 10, 5), (5, 6, 15, 10), (6, 7, 10, 5), (7, 8, 20, 15),
        (8, 9, 10, 5), (0, 3, 25, 20), (3, 6, 30, 25), (6, 9, 15, 10),
        (1, 7, 40, 30), (2, 8, 35, 25), (0, 2, 20, 15), (1, 3, 30, 20),
        (4, 6, 25, 20), (5, 7, 35, 25), (7, 9, 45, 30), (8, 0, 50, 35)
    ]

    for u, v, capacity, delay in edges:
        underlay.add_edge(u, v, capacity=capacity, delay=delay)


    return underlay

def create_overlay_network(underlay, overlay_nodes):
    # Create an empty graph
    overlay = nx.Graph()

    # Add nodes to overlay, ensuring they are also in underlay
    for node in overlay_nodes:
        if node in underlay:
            overlay.add_node(node)

    # Add overlay edges
    # Overlay edges should map to paths in the underlay network
    overlay.add_edge(0, 2)  # This represents an overlay link
    # ... more overlay links based on your design

    return overlay

def create_fully_connected_overlay_network(underlay, overlay_nodes):
    # Create an empty graph for the overlay network
    overlay = nx.Graph()

    # Add nodes to overlay, ensuring they are also in underlay
    for node in overlay_nodes:
        if node in underlay:
            overlay.add_node(node)

    # Initialize as a fully connected network
    for i in range(len(overlay_nodes)):
        for j in range(i + 1, len(overlay_nodes)):
            overlay.add_edge(overlay_nodes[i], overlay_nodes[j])

    # At this stage, all overlay links are potential and need to be activated based on the design algorithm
    return overlay

def minimum_spanning_tree(underlay):
    # Compute the minimum spanning tree of the underlay network
    mst = nx.minimum_spanning_tree(underlay, weight='delay')
    return mst

# Create underlay network
num_nodes = 10  # Example number of nodes
underlay = create_underlay_network(num_nodes)

# Create overlay network
# overlay_nodes = [0, 1, 2]  # Example nodes part of the overlay
# overlay = create_overlay_network(underlay, overlay_nodes)

# Compute the minimum spanning tree for routing
mst = minimum_spanning_tree(underlay)

# Let's display the edges of the MST
mst_edges = list(mst.edges(data=True))


# Example usage
overlay_nodes = [0, 1, 2, 3, 4]  # Example nodes part of the overlay
fully_connected_overlay = create_fully_connected_overlay_network(underlay, overlay_nodes)
print(fully_connected_overlay)
print(underlay)
# Now, apply an overlay design algorithm to determine which links to activate
# This step will depend on your specific criteria and objectives

import random

def activate_links_random_spanning_tree(overlay_network):
    """
    Generate a random spanning tree from the fully connected overlay network.
    This tree represents the activated overlay links.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) in the overlay network.
    """
    activated_links = set()
    nodes = list(overlay_network.nodes())
    random.shuffle(nodes)  # Shuffle to start from a random node

    # Start with one node and grow the spanning tree
    visited = {nodes[0]}
    while len(visited) < len(nodes):
        # Choose a random edge connecting the tree to a new node
        new_edge = random.choice([edge for edge in overlay_network.edges() if (edge[0] in visited) ^ (edge[1] in visited)])
        activated_links.add(new_edge)
        visited.update(new_edge)

    return activated_links

# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links = activate_links_random_spanning_tree(fully_connected_overlay)
activated_links

def activate_links_ring_topology(overlay_network):
    """
    Generate a ring topology from the fully connected overlay network.
    This configuration represents the activated overlay links in a ring structure.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) in the overlay network forming a ring.
    """
    activated_links = set()
    nodes = list(overlay_network.nodes())

    # Connect each node to its next node in the list, forming a ring
    for i in range(len(nodes)):
        next_node = nodes[(i + 1) % len(nodes)]  # Modulo for looping back to the first node
        activated_links.add((nodes[i], next_node))

    return activated_links

# Example usage
# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links_ring = activate_links_ring_topology(fully_connected_overlay)
activated_links_ring

def activate_links_greedy_topology(overlay_network):
    """
    Generate a network topology using a greedy algorithm from the fully connected overlay network.
    This function prioritizes links with the lowest delay.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) based on the greedy algorithm.
    """
    activated_links = set()
    nodes = set(overlay_network.nodes())
    visited = set()

    # Sort the edges based on delay (or another criterion)
    sorted_edges = sorted(overlay_network.edges(data=True), key=lambda x: x[2]['delay'])

    for edge in sorted_edges:
        u, v = edge[0], edge[1]
        # Check if adding the edge forms a cycle
        if u not in visited or v not in visited:
            activated_links.add((u, v))
            visited.update([u, v])

        # Stop if all nodes are visited
        if visited == nodes:
            break

    return activated_links

# Example usage
# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links_greedy = activate_links_greedy_topology(fully_connected_overlay)
activated_links_greedy


def activate_links_greedy_submodular(overlay_network):
    """
    Activate links in the overlay network using a Greedy Algorithm based on Submodular optimization.
    This example maximizes the total capacity of the activated links.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) based on the submodular optimization.
    """
    activated_links = set()
    nodes = set(overlay_network.nodes())
    visited = set()

    while visited != nodes:
        max_increase = 0
        best_edge = None

        for edge in overlay_network.edges(data=True):
            # Check if the edge connects to at least one new node and is not already in the activated set
            if (edge[0] in visited or edge[1] in visited) and edge not in activated_links:
                capacity_increase = edge[2]['capacity']

                # Select the edge that provides the maximum increase in capacity
                if capacity_increase > max_increase:
                    max_increase = capacity_increase
                    best_edge = edge

        if best_edge:
            activated_links.add(best_edge[:2])  # Add the edge without the data
            visited.update([best_edge[0], best_edge[1]])

    return activated_links

# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links_submodular = activate_links_greedy_submodular(fully_connected_overlay)
activated_links_submodular