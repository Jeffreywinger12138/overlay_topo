# -*- coding: utf-8 -*-
"""module_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FdlBrgUSoonWZR5JIhJ4dtRhUj2WUssT
"""

# u, v, capacity, delay
edges = [
    (0, 1, 10, 50), (1, 2, 15, 30), (2, 3, 10, 5), (3, 4, 20, 15),
    (4, 5, 10, 5), (5, 6, 15, 10), (6, 7, 10, 50), (7, 8, 20, 15),
    (8, 9, 10, 5), (0, 3, 25, 20), (3, 6, 30, 25), (6, 9, 15, 10),
    (1, 7, 40, 30), (2, 8, 35, 25), (0, 2, 20, 15), (1, 3, 30, 20),
    (4, 6, 25, 20), (5, 7, 35, 25), (7, 9, 45, 30), (8, 0, 50, 35)
]

# Use a sorted tuple (smaller index first) as the key
link_capacity_map = {tuple(sorted((edge[0], edge[1]))) : edge[2] for edge in edges}

key = tuple(sorted((1, 0)))
link_capacity_map[key]

import networkx as nx
!pip install gurobipy
def create_underlay_network(num_nodes, edges):
    # Create an empty graph
    underlay = nx.Graph()

    # # Add nodes
    # for i in range(num_nodes):
    #     underlay.add_node(i)

    # # Add edges with capacity and delay as attributes
    # # In a real scenario, these would be based on actual network data
    # underlay.add_edge(0, 1, capacity=10, delay=5)
    # underlay.add_edge(1, 2, capacity=15, delay=10)
    # # ... more edges based on your network design

    # Add more nodes
    for i in range(num_nodes):  # Increasing the number of nodes to 10
        underlay.add_node(i)

    # Add more edges with capacity and delay as attributes

    for u, v, capacity, delay in edges:
        underlay.add_edge(u, v, capacity=capacity, delay=delay)


    return underlay

def create_overlay_network(underlay, overlay_nodes):
    # Create an empty graph
    overlay = nx.Graph()

    # Add nodes to overlay, ensuring they are also in underlay
    for node in overlay_nodes:
        if node in underlay:
            overlay.add_node(node)

    # Add overlay edges
    # Overlay edges should map to paths in the underlay network
    overlay.add_edge(0, 2)  # This represents an overlay link
    # ... more overlay links based on your design

    return overlay

def create_fully_connected_overlay_network(underlay, overlay_nodes):
    # Create an empty graph for the overlay network
    overlay = nx.Graph()

    # Add nodes to overlay, ensuring they are also in underlay
    for node in overlay_nodes:
        if node in underlay:
            overlay.add_node(node)

    # Initialize as a fully connected network
    for i in range(len(overlay_nodes)):
        for j in range(i + 1, len(overlay_nodes)):
            overlay.add_edge(overlay_nodes[i], overlay_nodes[j])

    # At this stage, all overlay links are potential and need to be activated based on the design algorithm
    return overlay

def minimum_spanning_tree(underlay):
    # Compute the minimum spanning tree of the underlay network
    mst = nx.minimum_spanning_tree(underlay, weight='delay')
    return mst

# Create underlay network
num_nodes = 10  # Example number of nodes
underlay = create_underlay_network(num_nodes, edges)

# Compute the minimum spanning tree for routing
mst = minimum_spanning_tree(underlay)

# Let's display the edges of the MST
mst_edges = list(mst.edges(data=True))


# Example usage
overlay_nodes = [0, 1, 2, 3, 4]  # Example nodes part of the overlay
fully_connected_overlay = create_fully_connected_overlay_network(underlay, overlay_nodes)
print(fully_connected_overlay)
print(underlay)
# Now, apply an overlay design algorithm to determine which links to activate
# This step will depend on your specific criteria and objectives

def calculate_path_delays(mst, weight='delay'):
    path_delay_map = {}
    for source in mst.nodes():
        for target in mst.nodes():
            if source != target:
                # Use the weight parameter to consider the delay attribute on the edges
                path_delay = nx.shortest_path_length(mst, source, target, weight=weight)
                path_delay_map[(source, target)] = path_delay
    return path_delay_map


link_delay_map = calculate_path_delays(mst)

link_delay_map

"""**topo design**"""

import random

def activate_links_random_spanning_tree(overlay_network):
    """
    Generate a random spanning tree from the fully connected overlay network.
    This tree represents the activated overlay links.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) in the overlay network.
    """
    activated_links = set()
    nodes = list(overlay_network.nodes())
    random.shuffle(nodes)  # Shuffle to start from a random node

    # Start with one node and grow the spanning tree
    visited = {nodes[0]}
    while len(visited) < len(nodes):
        # Choose a random edge connecting the tree to a new node
        new_edge = random.choice([edge for edge in overlay_network.edges() if (edge[0] in visited) ^ (edge[1] in visited)])
        activated_links.add(tuple(sorted(new_edge)))
        visited.update(new_edge)

    return activated_links

# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links = activate_links_random_spanning_tree(fully_connected_overlay)
activated_links

def activate_links_ring_topology(overlay_network):
    """
    Generate a ring topology from the fully connected overlay network.
    This configuration represents the activated overlay links in a ring structure.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) in the overlay network forming a ring.
    """
    activated_links = set()
    nodes = list(overlay_network.nodes())

    # Connect each node to its next node in the list, forming a ring
    for i in range(len(nodes)):
        next_node = nodes[(i + 1) % len(nodes)]  # Modulo for looping back to the first node
        activated_links.add((nodes[i], next_node))

    return activated_links

# Example usage
# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links_ring = activate_links_ring_topology(fully_connected_overlay)
activated_links_ring

import matplotlib.pyplot as plt

def draw_underlay_network_with_mst(underlay, mst):
    # Setting up the plot
    plt.figure(figsize=(10, 8))

    # Position nodes using a spring layout
    pos = nx.spring_layout(underlay)

    # Draw underlay network
    nx.draw_networkx_nodes(underlay, pos, node_color='lightblue', label='Underlay Nodes')
    nx.draw_networkx_edges(underlay, pos, alpha=0.3, edge_color='gray', label='Underlay Edges')

    # Draw Minimum Spanning Tree
    mst_edges = mst.edges()
    nx.draw_networkx_edges(mst, pos, edgelist=mst_edges, edge_color='green', label='MST Edges', style='dashdot')

    # Draw node labels
    nx.draw_networkx_labels(underlay, pos)

    # Set plot title and legends
    plt.title('Underlay Network with MST')
    plt.legend()

    # Display the plot
    plt.show()

# Draw only the underlay network and its MST
draw_underlay_network_with_mst(underlay, mst)

def draw_fully_connected_overlay_network(overlay, overlay_nodes, activated_links):
    # Setting up the plot
    plt.figure(figsize=(10, 8))

    # Position nodes using a spring layout
    pos = nx.spring_layout(overlay)

    # Draw overlay network
    nx.draw_networkx_nodes(overlay, pos, nodelist=overlay_nodes, node_color='yellow', label='Overlay Nodes')
    nx.draw_networkx_edges(overlay, pos, edgelist=overlay.edges(), edge_color='blue', label='Overlay Edges', style='dotted')

    # Draw activated overlay links
    nx.draw_networkx_edges(overlay, pos, edgelist=activated_links, edge_color='red', label='Activated Overlay Links', style='solid')

    # Draw node labels
    nx.draw_networkx_labels(overlay, pos)

    # Set plot title and legends
    plt.title('Fully Connected Overlay Network with Activated Links')
    plt.legend()

    # Display the plot
    plt.show()

# Draw only the fully connected overlay network
draw_fully_connected_overlay_network(fully_connected_overlay, overlay_nodes, activated_links)

# Now define the multicast demands
def define_multicast_demands(activated_links, source_node, data_size):
    destinations = {v for u, v in activated_links if u == source_node} | {u for u, v in activated_links if v == source_node}
    multicast_demand = (source_node, destinations, data_size)
    return multicast_demand

# Node 2 needs to multicast to other nodes
source_node_list = [0,4]
multicast_demands= []
data_size = 100  # Assume a data size of 100
for source_node in source_node_list:
    multicast_demands.append(define_multicast_demands(activated_links, source_node, data_size))

multicast_demands

link_delay_map[(2,0)]

H=[]
# Initialize an empty list to hold both original and reversed links
Ea = []
overlay_links = []
# Populate the undirected_links list
for link in fully_connected_overlay.edges():
    overlay_links.append(link)  # Add original direction
    overlay_links.append(link[::-1])  # Add reverse direction

print(overlay_links)
# Populate the undirected_links list
for link in list(activated_links):
    Ea.append(link)  # Add original direction
    Ea.append(link[::-1])  # Add reverse direction

for source, destinations, data_size in multicast_demands:
    for destination in destinations:
        H.append((source, destination, data_size))

print(H)

def map_overlay_to_mst_edges(mst, overlay_links):
    # Initialize a dictionary to hold the list of demands for each edge in the MST
    # mst network
    # demand set H
    overlay_links_map = {(u, v): [] for u, v in mst.edges()}

    # Iterate over each demand
    for source, destination in overlay_links:
        # Find the path in the MST from source to destination
        path = nx.shortest_path(mst, source=source, target=destination)

        # Go through the path and add the demand to each edge on the path
        for i in range(len(path) - 1):
            edge = tuple(sorted((path[i], path[i+1])))
            # For undirected graphs, we need to consider that the edge might be in either direction
            if edge in overlay_links_map:
                overlay_links_map[edge].append((source, destination))

    return overlay_links_map

overlay_links_map = map_overlay_to_mst_edges(mst,overlay_links)

mst_edges

from gurobipy import Model, GRB, quicksum

# Placeholder for initialization of Gurobi model
m = Model("tau_optimization")

# Assuming we have the following maps (as you mentioned)
# link_capacity_map: A Python map from an underlay link to its capacity, C_e
# link_delay_map: A Python map from an underlay link to its delay, l_ij

M = 1000 # This is a large constant, set it to a large enough value to act as 'infinity'
# Define decision variables
# z = m.addVars(Ea, H, vtype=GRB.BINARY, name="z") #.  ------?
# f = m.addVars(directed_links, H, vtype=GRB.CONTINUOUS, name="f", lb=0)
z = {}
f = {}
d = {}
d_inv = {}
for h in multicast_demands:
    source, T_h, data_size = h
    # Convert destinations to a frozenset for immutability and to ensure uniqueness
    h_index = (source, frozenset(T_h), data_size)
    d[h_index] = m.addVar(vtype=GRB.CONTINUOUS, name=f"d_{h_index}", lb=0, ub=M)
    d_inv[h_index] = m.addVar(vtype=GRB.CONTINUOUS, name=f"inv_{h_index}")

    # Create the inverse constraint for d and d_inv
    m.addConstr(d_inv[h_index] * d[h_index] == 1, name=f"inv_constraint_{h_index}")

    # Iterate through each overlay link and create binary variables z and flow variables f for each demand
    for i, j in overlay_links:
        link_index = (i, j)
        z[(link_index, h_index)] = m.addVar(vtype=GRB.BINARY, name=f"z_{link_index}_{h_index}")
        f[(link_index, h_index)] = m.addVar(vtype=GRB.CONTINUOUS, name=f"f_{link_index}_{h_index}", lb=0)

r = m.addVars(overlay_links, H, vtype=GRB.BINARY, name="r")

# Objective: Minimize tau
tau = m.addVar(vtype=GRB.CONTINUOUS, name="tau")
m.setObjective(tau, GRB.MINIMIZE)

# Constraints
# (5b) Tau is an upper bound on the completion time of the slowest flow
for s_h, T_h, k_h in multicast_demands:
    for k in T_h:
        m.addConstr(tau >= k_h * d_inv[s_h, frozenset(T_h), k_h] + quicksum(link_delay_map[i, j] * r[i, j, s_h, k, k_h] for i, j in overlay_links))

# (5c) The total traffic rate imposed by the overlay on any underlay link is within its capacity
for u,v,_ in mst_edges:
    underlay_link = tuple(sorted((u,v)))
    if overlay_links_map[underlay_link]:
        m.addConstr(quicksum(f[ovelaylink, (s_h, frozenset(T_h), k_h)] for ovelaylink in overlay_links_map[underlay_link] for s_h, T_h, k_h in multicast_demands) <= link_capacity_map[underlay_link])

# (5d) Flow conservation for non-source, non-destination nodes
for s_h, k, k_h  in H:
    for i in overlay_nodes:
        b = 1 if i==s_h else (-1 if i==k else 0)
        m.addConstr(quicksum(r[i, j, s_h, k, k_h] for j in overlay_nodes if (i, j) in Ea) ==
                    quicksum(r[j, i, s_h, k, k_h] for j in overlay_nodes if (i, j) in Ea) + b)

# (5e) Flow only happens on active paths
for s_h, T_h, k_h in multicast_demands:
    for k in T_h:
        for i, j in overlay_links:
            m.addConstr(r[i, j, s_h, k, k_h] <= z[(i, j), (s_h, frozenset(T_h), k_h)])

# Constraint (5f): If z_ij^h is 0 (link (i,j) is not used by flow h), then f_ij^h must be 0; otherwise, it's bounded by d_h
for s_h, T_h, k_h in multicast_demands:
    for i, j in overlay_links:
        m.addConstr(d[s_h, frozenset(T_h), k_h] - M * (1 - z[(i, j), (s_h, frozenset(T_h), k_h)]) <= f[(i, j), (s_h, frozenset(T_h), k_h)], name=f"flow_lower_bound_{s_h}_{T_h}_{k_h}_{i}_{j}")
        m.addConstr(f[(i, j), (s_h, frozenset(T_h), k_h)] <= d[s_h, frozenset(T_h), k_h], name=f"flow_upper_bound_{s_h}_{T_h}_{k_h}_{i}_{j}")


# # (5g) Flow rate f is less than or equal to M times the binary decision on z
# for h in H:
#     for i, j in Ea:
#         m.addConstr(f[h, i, j] <= M * z[h, i, j])

# Optimize the model
m.optimize()

# Print the results
if m.status == GRB.OPTIMAL:
    print('Optimal value of tau:', tau.X)
else:
    print('No optimal solution found')

r

import mosek

# Function to define the optimization problem and solve it using MOSEK
def optimize_with_mosek(B, J, Ea):
    with mosek.Env() as env:
        with env.Task(0, 0) as task:
            # Assume `n` is the dimension of the square matrices involved
            n = B.shape[0]

            # Assuming `alpha` is a vector that we want to optimize
            num_vars = len(alpha)
            task.appendvars(num_vars)

            # Set the objective to minimize alpha (which is presumably related to rho)
            # Here, we need the indices of alpha in the problem, which we assume are 0 to num_vars-1
            task.putcfix(0.0)  # Set the fixed part of the objective.
            for j in range(num_vars):
                task.putcj(j, 1.0)  # Coefficient for variable j in the objective

            # Add constraints for alpha_ij = 0 for all (i, j) not in Ea
            # Here, you would need to define the indices properly based on Ea
            for (i, j) in some_indices_not_in_Ea:
                # Set alpha_ij to 0
                task.putaij(i, j, 1.0)  # Add a constraint matrix coefficient at position (i, j)
                task.putconbound(i, mosek.boundkey.fx, 0.0, 0.0)  # Fix alpha_ij to 0

            # Define the matrix inequality constraint -rho*I <= I - B*diag(alpha)*B^T - J <= rho*I
            # This part would require setting up semidefinite cones and matrix variables in MOSEK
            # Since this is quite involved and requires the specifics of the matrices, it is left as a placeholder

            # Assume a function to set up the semidefinite constraint exists
            setup_sdp_constraint(task, B, J)

            # Input the problem data into the task
            # (This step is where you would populate the task with the actual data of your problem)

            # Solve the problem
            task.optimize()

            # Extract the solution
            xx = [0.] * num_vars
            task.getxx(mosek.soltype.itr, xx)

            # The variable xx contains the solution
            return xx

# Placeholder function for setting up the semidefinite constraint
# You would need to replace this with actual implementation
def setup_sdp_constraint(task, B, J):
    pass

# Example usage:
# Define your matrices B, J, and the set Ea accordingly
B = ...
J = ...
Ea = ...

# Solve the optimization problem
alpha_optimal = optimize_with_mosek(B, J, Ea)

"""**Prim** **algorithm**"""

import heapq

def activate_links_prim_topology(overlay_network):
    """
    Generate a topology based on Prim's algorithm from the overlay network.
    This configuration represents the activated overlay links forming a minimum spanning tree.

    :param overlay_network: A weighted overlay network.
    :return: A set of activated links (edges) in the overlay network forming a minimum spanning tree.
    """
    activated_links = set()

    # Choose an arbitrary starting node
    start_node = next(iter(overlay_network.nodes()))
    visited = set([start_node])

    # Create a priority queue and add all edges from the start node to the queue
    edges = [(weight, start_node, to) for to, weight in overlay_network[start_node].items()]
    heapq.heapify(edges)

    while edges:
        weight, from_node, to_node = heapq.heappop(edges)
        if to_node not in visited:
            visited.add(to_node)
            activated_links.add((from_node, to_node))

            # Add all edges from the new node to the queue
            for next_node, next_weight in overlay_network[to_node].items():
                if next_node not in visited:
                    heapq.heappush(edges, (next_weight, to_node, next_node))

    return activated_links

# Example usage
# Assuming 'weighted_overlay_network' is the weighted

"""**`Christofides’ Algorithm`**"""

import networkx as nx

def find_minimum_spanning_tree(G):
    return nx.minimum_spanning_tree(G)

def find_odd_degree_vertices(G):
    return [v for v in G.nodes() if G.degree(v) % 2 == 1]

def add_minimum_weight_matching(G, odd_degree_vertices):
    # Create a complete graph with all odd degree vertices
    complete_graph = nx.Graph()
    for i in range(len(odd_degree_vertices)):
        for j in range(i + 1, len(odd_degree_vertices)):
            v1, v2 = odd_degree_vertices[i], odd_degree_vertices[j]
            complete_graph.add_edge(v1, v2, weight=nx.shortest_path_length(G, v1, v2))

    # Find the minimum weight matching
    matching = nx.algorithms.matching.min_weight_matching(complete_graph, maxcardinality=True)

    # Add the matching edges to the original graph
    for edge in matching:
        G.add_edge(*edge)

def create_eulerian_circuit(G):
    # Assumes G is now Eulerian
    return list(nx.eulerian_circuit(G))

def activate_links_christofides_algorithm(G):
    # Step 1: Create a minimum spanning tree
    mst = find_minimum_spanning_tree(G)

    # Step 2: Find vertices of odd degree
    odd_degree_vertices = find_odd_degree_vertices(mst)

    # Step 3: Add minimum weight matching
    add_minimum_weight_matching(mst, odd_degree_vertices)

    # Step 4: Create Eulerian circuit
    eulerian_circuit = create_eulerian_circuit(mst)

    # Step 5: Convert to a Hamiltonian path by skipping visited nodes
    hamiltonian_path = []
    visited = set()
    for u, v in eulerian_circuit:
        if u not in visited:
            hamiltonian_path.append(u)
            visited.add(u)
        if v not in visited:
            hamiltonian_path.append(v)
            visited.add(v)

    return hamiltonian_path

# Example usage
# Assuming 'weighted_overlay_network' is the weighted overlay network
weighted_overlay_network = nx.Graph() # Replace this with your network definition
# Add nodes and edges to 'weighted_overlay_network'
activated_links_christofides = activate_links_christofides_algorithm(weighted_overlay_network)
activated_links_christofides

"""**Algorithm 1**"""

import networkx as nx

def δ_prim(graph, δ):
    # This is a placeholder for the δ-Prim's algorithm.
    # You need to implement the δ-Prim's algorithm as per the paper's definition.
    pass

def approximate_algorithm_for_MCT(overlay_network, C_up, l, T_c, M):
    """
    :param overlay_network: The input graph G_c (V, E_c).
    :param C_up: Dictionary with uplink capacities C_up(i) for each node i.
    :param l: Dictionary with end-to-end delay l(i, j) for each edge (i, j).
    :param T_c: Dictionary with computation time T_c(i) for each node i.
    :param M: Model size.
    :return: The undirected overlay G_o as a NetworkX Graph.
    """
    # Step 1: Create G_c^w
    G_c_w = nx.Graph()
    for i, j in overlay_network.edges():
        G_c_w.add_edge(i, j, weight=(
            l[(i, j)] + l[(j, i)] + T_c[i] + T_c[j] +
            M / C_up[i] + M / C_up[j]
        ) / 2)

    # Step 5-9: Consider 2-MBST approximate solution on G_c^w as one candidate
    T = nx.minimum_spanning_tree(G_c_w)
    T_cubed = nx.power(T, 3)  # This is not directly supported in NetworkX, needs implementation
    H = find_hamiltonian_path(T_cubed)  # Hamiltonian path is not directly supported, this is a placeholder
    candidates = [H]

    # Step 10-12: Consider other δ-BST for 3 ≤ δ ≤ N as candidates
    for δ in range(3, overlay_network.number_of_nodes() + 1):
        candidates.append(δ_prim(G_c_w, δ))

    # Step 13: Choose the one with the minimum cycle time as output overlay
    min_cycle_time = float('inf')
    G_o = None
    for candidate in candidates:
        cycle_time = calculate_cycle_time(candidate, C_up, l, T_c, M)  # Placeholder for cycle time calculation
        if cycle_time < min_cycle_time:
            min_cycle_time = cycle_time
            G_o = candidate

    return G_o

# Helper functions needed:
# - find_hamiltonian_path()
# - calculate_cycle_time()
# - δ-Prim's algorithm implementation

# This is an outline, and actual implementation details are needed for each helper function.

def activate_links_greedy_topology(overlay_network):
    """
    Generate a network topology using a greedy algorithm from the fully connected overlay network.
    This function prioritizes links with the lowest delay.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) based on the greedy algorithm.
    """
    activated_links = set()
    nodes = set(overlay_network.nodes())
    visited = set()

    # Sort the edges based on delay (or another criterion)
    sorted_edges = sorted(overlay_network.edges(data=True), key=lambda x: x[2]['delay'])

    for edge in sorted_edges:
        u, v = edge[0], edge[1]
        # Check if adding the edge forms a cycle
        if u not in visited or v not in visited:
            activated_links.add((u, v))
            visited.update([u, v])

        # Stop if all nodes are visited
        if visited == nodes:
            break

    return activated_links

# Example usage
# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links_greedy = activate_links_greedy_topology(fully_connected_overlay)
activated_links_greedy


def activate_links_greedy_submodular(overlay_network):
    """
    Activate links in the overlay network using a Greedy Algorithm based on Submodular optimization.
    This example maximizes the total capacity of the activated links.

    :param overlay_network: A fully connected overlay network.
    :return: A set of activated links (edges) based on the submodular optimization.
    """
    activated_links = set()
    nodes = set(overlay_network.nodes())
    visited = set()

    while visited != nodes:
        max_increase = 0
        best_edge = None

        for edge in overlay_network.edges(data=True):
            # Check if the edge connects to at least one new node and is not already in the activated set
            if (edge[0] in visited or edge[1] in visited) and edge not in activated_links:
                capacity_increase = edge[2]['capacity']

                # Select the edge that provides the maximum increase in capacity
                if capacity_increase > max_increase:
                    max_increase = capacity_increase
                    best_edge = edge

        if best_edge:
            activated_links.add(best_edge[:2])  # Add the edge without the data
            visited.update([best_edge[0], best_edge[1]])

    return activated_links

# Assuming 'fully_connected_overlay' is the fully connected overlay network
activated_links_submodular = activate_links_greedy_submodular(fully_connected_overlay)
activated_links_submodular

import networkx as nx

def calculate_overall_delay(network, packet_size, start_node, end_node):
    """
    Calculate the overall delay (propagation + transmission) from start_node to end_node.

    :param network: The network graph
    :param packet_size: Size of the packet in bits
    :param start_node: Starting node
    :param end_node: Ending node
    :return: Overall delay
    """
    # Find the shortest path from start_node to end_node
    path = nx.shortest_path(network, source=start_node, target=end_node)

    # Initialize overall delay
    total_delay = 0

    # Iterate over the path to calculate delays
    for i in range(len(path) - 1):
        u, v = path[i], path[i + 1]

        # Get the propagation delay and capacity for the link
        prop_delay = network[u][v]['delay']
        capacity = network[u][v]['capacity']  # capacity in bits per second

        # Calculate transmission delay
        trans_delay = packet_size / capacity

        # Add both delays to the total delay
        total_delay += prop_delay + trans_delay

    return total_delay

# Example usage:
# Create a network
network = nx.Graph()
network.add_edge('A', 'B', capacity=1000, delay=0.01)  # 1 Kbps, 10 ms
network.add_edge('B', 'C', capacity=500, delay=0.02)   # 0.5 Kbps, 20 ms
network.add_edge('A', 'C', capacity=1000, delay=0.05)  # 1 Kbps, 50 ms

# Calculate overall delay for a packet of size 8000 bits from A to C
overall_delay = calculate_overall_delay(network, 8000, 'A', 'C')
print(f"Overall delay from A to C: {overall_delay} seconds")